
            # This is and autogenerated test case using PyUDS Test Builder v0.1 #
        
from framework.shared_functions import device_under_test, ARC_sys_vars, sleep_timeout, tools
from Testcases.TestClass import TestCase
from inspect import stack as info
import unittest, time, os, random

test = TestCase()
class PyUDS_TestCase(unittest.TestCase):

    #== CG3531 - Network Supervision ==#
    @classmethod
    def setUpClass(self):
        #== Initialize test case ==#
        test.begin(
            test_info=info(),
            writeTestResults=True,
            excel_tab='Network Supervision'
        )

        ''' Device Under Test - Settings '''
        self.sys_vars = tuple(ARC_sys_vars[device_under_test].keys())

        self.test_step_counter=1
        self.invalid_signal_DTCs = {
            "ARB":{
                "VehSpdAvgDrvn_Prtcd_MSG":{
                    "ID":"614","ARC":1,"PV":0,"CS":0,"RATE":100,
                    "DTC":{
                        "C4 01 00":{"x":8,"y":1000,"cal":0}
                    }
                },
                "TrnsEstGr_Prtcd_MSG":{
                    "ID":"50","ARC":1,"PV":0,"CS":0,"RATE":12.5,
                    "DTC":{
                        "C4 01 00":{"x":16,"y":720,"cal":0},
                        "C4 11 00":{"x":1,"y":1000,"cal":0},
                        "C4 02 00":{"x":1,"y":1000,"cal":1},
                    }
                },
                "SysPwrMode_Prtcd_MSG":{
                    "ID":"878","ARC":1,"PV":1,"CS":0,"RATE":250,
                    "DTC":{
                        "C4 22 00":{"x":8,"y":2500,"cal":0}
                    }
                },
                "BkupSysPwrMode_Prtctd_MSG":{
                    "ID":"880","ARC":1,"PV":1,"CS":0,"RATE":250,
                    "DTC":{
                        "C4 47 00":{"x":8,"y":2500,"cal":0}
                    }
                }
            }
        }
    @classmethod
    def tearDownClass(self):
        #== End Test Case ==#
        test.end()
    
    def current_step(self):
        return 'test_' + str(self.test_step_counter).rjust(3,'0')

    def count_step(self):
        self.test_step_counter+=2

    def test_001_1(self, name='Start Test'):
        # Pre condition - Clear DTCs before starting the TC
        test.preconditions(
            current_step='Clear DTCs - Precondition',
            #power_mode='RUN',
            mec_zero=True
        )
        test.step(
            step_title='Read MEC',
            custom='22 F1 A0',
            expected={
                'response': 'Positive',
                'data': '00'
            }
        )
        time.sleep(5)

        for msg in self.invalid_signal_DTCs[device_under_test].keys():
            print(msg)
            if self.invalid_signal_DTCs[device_under_test][msg]['ARC'] == 1:
                self.Msg_ID=self.invalid_signal_DTCs[device_under_test][msg]['ID']
                self.Msg_rate=self.invalid_signal_DTCs[device_under_test][msg]['RATE']
                self.Msg_DTC=list(self.invalid_signal_DTCs[device_under_test][msg]['DTC'].keys())[0]
                self.Msg_x=self.invalid_signal_DTCs[device_under_test][msg]['DTC'][self.Msg_DTC]['x']
                
                self.count_step()
                test.preconditions(
                    current_step=self.current_step() + '_2'
                )
                test.step(
                    step_title='Clear DTCs - Precondition',
                    custom='14 FF FF FF',
                    expected={
                        'response': 'Positive'
                    }
                )
                test.preconditions(current_step=self.current_step() + '_3')
                test.step(
                    step_title='Read DTCs - Not DTCs are set',
                    custom='19 02 09',
                    expected={
                        'response': 'Positive',
                        'data': 'FF'
                    }
                )
                
                self.count_step()
                test.preconditions(
                    current_step=self.current_step()
                )

                
                #Read DTCs at the message peridic rate until DTC sets
                test.canoe.set_envVariable(envReadingPeriod=self.Msg_rate)
                time.sleep(0.1)
                test.canoe.set_system_variable('Generic_Functional','TriggerDTCRead','1')
                #Step 4 Start sending msg with invalid signal
                test.canoe.set_envVariable(Env_MsgID = self.Msg_ID)
                test.canoe.set_system_variable('SysVarSecMsg','SysInValidDataCount','1')
                test.canoe.set_system_variable('SysVarSecMsg','SysInvalidARC','1')
                test.canoe.set_envVariable(Env_MsgStartStop='INVALIDARC')
                time.sleep(6)
                test.canoe.set_system_variable('Generic_Functional','TriggerDTCRead','0')
                
                #Manually check in RBS trace if the DTC is not set befor X count and sets after X count
                prompt = tools.popup.ask(title=name, description='Verify invalidSignal DTCs sets only after X instances for Y ms')
                test.compare(True, prompt, step='test_004')     
                

                
                #Read DTCs at the message peridic rate
                test.canoe.set_envVariable(envReadingPeriod=self.Msg_rate)
                time.sleep(0.1)
                test.canoe.set_system_variable('Generic_Functional','TriggerDTCRead','1')
                #Step 5 Transmit with Valid ARC  
                test.canoe.set_envVariable(Env_MsgID = self.Msg_ID)
                test.canoe.set_system_variable('SysVarSecMsg','SysInValidDataCount','0')
                test.canoe.set_system_variable('SysVarSecMsg','SysInvalidARC','0')
                test.canoe.set_envVariable(Env_MsgStartStop='INVALIDARC')
                time.sleep(3)
                test.canoe.set_system_variable('Generic_Functional','TriggerDTCRead','0')
                
                #Manually check in RBS trace if the DTC testFailed bit goes to 0 after two instances of Valid ARC
                prompt = tools.popup.ask(title=name, description='Verify invalidSignal DTCs status byte is 2E after two instances of Valid ARC')
                test.compare(True, prompt, step='test_005')      

                self.count_step() 
                test.preconditions(
                    current_step=self.current_step()
                )
                #Step 7
                test.step(
                    step_title='Clear DTCs - Precondition',
                    custom='14 FF FF FF',
                    expected={
                        'response': 'Positive'
                    }
                )
                #Step 8
                time.sleep(5.1)
                #Step 9
                self.count_step()
                test.preconditions(
                    current_step=self.current_step()
                )
                test.step( 
                    step_title='{0} - {1}::{2}'.format('Read DTC - DTC remains 2E', device_under_test, self.Msg_ID),
                    custom='19 02 09',
                    expected={
                        'response':     'Positive',
                        'data':  'FF'
                    }
                )
                
                #Step 10 Transmit the received message with the following Invalid/Valid ARC pattern:
                #less than X_Failure_Count Limit number of messages with invalid ARC (Invalid):
                invalid_msgs_count=(int(self.Msg_x)-2) 
                invalid_msgs_count=(invalid_msgs_count-1)*2
                print(invalid_msgs_count)
                
                #followed by 2 times X_Failure_Count Limit number of messages with Valid ARC (Valid) :
                
                valid_msgs_count=(int(self.Msg_x)*2)
                valid_msgs_count=(valid_msgs_count+1)*2
                print(valid_msgs_count)
                print(hex(valid_msgs_count))
                #for a duration of at least 10 cycles of Invalid/Valid data:
                ms_data_cycles = 10*(invalid_msgs_count+valid_msgs_count)/2*self.Msg_rate
                print(ms_data_cycles)
                if invalid_msgs_count >0:
                    test.canoe.set_envVariable(Env_MsgID = self.Msg_ID)
                    test.canoe.set_system_variable('SysVarSecMsg','SysInValidDataCount','9')
                    test.canoe.set_system_variable('SysVarSecMsg','SysValidDataCount',hex(valid_msgs_count))
                    test.canoe.set_system_variable('SysVarSecMsg','SysInvalidARC','1')
                    test.canoe.set_envVariable(Env_MsgStartStop='INVALIDARC')
                    time.sleep(ms_data_cycles/1000)
                    test.canoe.set_system_variable('SysVarSecMsg','SysInValidDataCount','0')
                    test.canoe.set_system_variable('SysVarSecMsg','SysValidDataCount','0')
                    test.canoe.set_system_variable('SysVarSecMsg','SysInvalidARC','0')
                    test.canoe.set_envVariable(Env_MsgStartStop='INVALIDARC')

                time.sleep(1)
                
                #Manually check in RBS trace if the Messages valid/invalid cycles are correct
                prompt = tools.popup.ask(title=name, description='Verify if the Messages invalid/valid cycles are correct')
                test.compare(True, prompt, step='test_009')
                
                #Step 11 Check no DTCs set
                self.count_step()
                test.preconditions(
                    current_step=self.current_step()
                )
                test.step(
                    step_title='{0} - {1}'.format('Read DTC - Must be clear', device_under_test),
                    custom='19 02 09',
                    expected={
                        'response': 'Positive',
                        'data': 'FF'
                    }
                )
