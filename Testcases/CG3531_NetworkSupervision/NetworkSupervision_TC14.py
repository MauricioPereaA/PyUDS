
            # This is and autogenerated test case using PyUDS Test Builder v0.1 #
        
from framework.shared_functions import device_under_test, pn_dict, tools
from Testcases.TestClass import TestCase
from inspect import stack as info
import unittest, time

test = TestCase()
class PyUDS_TestCase(unittest.TestCase):

    #== Positive Flow Diagnostic Session Control Session and Security Tests ==#
    @classmethod
    def setUpClass(self):
        #== Initialize test case ==#
        test.begin(
            test_info=info(),
            step_delay=0.0025,
            writeTestResults=True,
            excel_tab='Network Supervision'
        )
        #== Device Under Test - Settings ==#
        self.protected_messages = pn_dict[device_under_test]['protected_messages']
        self.supported_pns = pn_dict[device_under_test]['supported_PNs']
        self.test_step_counter=2

    @classmethod
    def tearDownClass(self):
        #== End Test Case ==#
        test.end()

    def current_step(self):
        return str(self.test_step_counter).rjust(3,'0')

    def count_step(self):
        self.test_step_counter+=1

    def test_001(self, name='Test all Lost Comm DTCs'):
        # Test supervised message one by one
        for protected_message in self.protected_messages.keys():
            
            #step 2_1
            test.preconditions(
                current_step='test_%s'%self.current_step()
            )
            time.sleep(5)
            test.step(
                step_title=name,
                custom='14 FF FF FF',
                expected={
                    'response': 'Positive'
                }
            )
            
            #step 2_2
            self.count_step()
            test.preconditions(
                current_step='test_%s'%self.current_step()
            )
            test.step(
                step_title='{0} - {1}'.format(name, device_under_test),
                custom='19 02 09',
                expected={
                    'response':     'Positive',                
                    'data'    :     'FF'
                }
            )  
            #Step 6 Allow the ECU to transition to sleep state     
            test.canoe.set_envVariable(envVNMFSend=0)
            test.canoe.set_envVariable(envVNMFStop=1)
            
            #Step 7 Wait the time required for ECU to reach Sleep State.
            for s in reversed(range(50)): #sleep time
                # Wait for 'n' seconds until the module goes to sleep
                #  - Where 'n' = sleep_timeout integer value specified in config file
                print(s, end='  ', flush=True)
                time.sleep(1)
                
            #step 8 Stop the RBS from transmitting one message that the ECU supervises
            test.canoe.set_envVariable(**dict({protected_message:1}))
            
            #Step 9 Perform server WakeUp
            test.canoe.set_envVariable(envVNMFStop=0)
            test.canoe.set_envVariable(envVNMFSend=1)

            self.count_step()
            test.preconditions(
                current_step='test_%s'%self.current_step()
            )
            #step 10 and 11 Read DTCs every 1 second for 10 seconds
            test.canoe.set_envVariable(envReadingPeriod=1000)
            time.sleep(0.1)
            test.canoe.set_system_variable('Generic_Functional','TriggerDTCRead','1')
            time.sleep(11)
            test.canoe.set_system_variable('Generic_Functional','TriggerDTCRead','0')
            
            prompt = tools.popup.ask(title=name, description='Please check replies to 19 02 09 show LOC DTC after 5 seconds - record time')
            test.compare(True, prompt, step='test_011')
            #Enable message for next cycle.
            test.canoe.set_envVariable(**dict({protected_message:0}))

