'''
    TestScript intended to perform Unit Testing for pyUDS 0x2A Service
'''
'''
Author: Mauricio Perea

This script is intended to validate Functionality of service 0x2A which main function is to request the periodic transmission of data record values from the server by one or more periodicDataIdentifiers (PDID).


'''
            # This is and autogenerated test case using PyUDS Test Builder v0.1 #

from framework.shared_functions import tools, device_under_test
from Testcases.TestClass import TestCase
from inspect import stack as info
import unittest, time

test = TestCase()
class PyUDS_TestCase(unittest.TestCase):

    #== Positive Flow Diagnostic Session Control Session and Security Tests ==#
    @classmethod
    def setUpClass(self):
        #== Initialize test case ==#
        if device_under_test is 'SCL':
            tools.popup.warning(
                title='Service 0x2A not supported',
                description='SCL does not support service 0x2A'
            )
            raise Warning('SCL does not support service 0x2A')
        test.begin(
            test_info=info(),
            writeTestResults=False,
            excel_tab='0x2A'
        )

        self.s3_timeout = 0.1

    @classmethod
    def tearDownClass(self):
        #== End Test Case ==#
        test.end()


    def test_001(self, name='Transition Server to ExtendedSession'):
        test.preconditions(
            step_info=info(),
            sbat=False, # Clear SBAT
            mec_zero=True
        )
        test.step(
            step_title=name,
            custom='10 03',
            expected={
                'response': 'Positive'
            }
        )

    def test_002(self, name='Activate tester present'):
        test.preconditions(
            step_info=info(),
            functionalAddr=True
        )
        test.step(
            step_title=name,
            start_tester_present=True,
            expected={
                'response': 'No response'
            }
        )

    def test_003(self, name='DynamicallyDefineDataIdentifier  2C - F0-FF'):
        test.preconditions(
            step_info=info()
        )
        test.step(
            step_title=name,
            custom='2C 01 F2 FF F0 80 01 01',
            expected={
                'response': 'Positive'
            }
        )

        test.preconditions(
            step_info=info()
        )

        test.step(
            step_title=name,
            custom='2C 01 F2 FE F0 81 01 01',
            expected={
                'response': 'Positive'
            }
        )

        test.preconditions(
            step_info=info()
        )

        test.step(
            step_title=name,
            custom='2C 01 F2 FD F0 84 01 01',
            expected={
                'response': 'Positive'
            }
        )

        test.preconditions(
            step_info=info()
        )

        test.step(
            step_title=name,
            custom='2C 01 F2 FC F0 89 01 01',
            expected={
                'response': 'Positive'
            }
        )

        test.preconditions(
            step_info=info()
        )

        test.step(
            step_title=name,
            custom='2C 01 F2 FB F0 8E 01 01',
            expected={
                'response': 'Positive'
            }
        )

        test.preconditions(
            step_info=info()
        )
        test.step(
            step_title=name,
            custom='2C 01 F2 FA F0 8F 01 01',
            expected={
                'response': 'Positive'
            }
        )

        test.preconditions(
            step_info=info()
        )
        test.step(
            step_title=name,
            custom='2C 01 F2 F9 F0 90 01 01',
            expected={
                'response': 'Positive'
            }
        )

        test.preconditions(
            step_info=info()
        )
        test.step(
            step_title=name,
            custom='2C 01 F2 F8 F0 91 01 01',
            expected={
                'response': 'Positive'
            }
        )

        test.preconditions(
            step_info=info()
        )

        test.step(
            step_title=name,
            custom='2C 01 F2 F7 F0 92 01 01',
            expected={
                'response': 'Positive'
            }
        )

        test.preconditions(
            step_info=info()
        )

        test.step(
            step_title=name,
            custom='2C 01 F2 F6 F0 94 01 01',
            expected={
                'response': 'Positive'
            }
        )

        test.preconditions(
            step_info=info()
        )

        test.step(
            step_title=name,
            custom='2C 01 F2 F5 F0 95 01 01',
            expected={
                'response': 'Positive'
            }
        )

        test.preconditions(
            step_info=info()
        )

        test.step(
            step_title=name,
            custom='2C 01 F2 F4 F0 A7 01 01',
            expected={
                'response': 'Positive'
            }
        )

        test.preconditions(
            step_info=info()
        )

        test.step(
            step_title=name,
            custom='2C 01 F2 F3 F0 84 01 01',
            expected={
                'response': 'Positive'
            }
        )

        test.preconditions(
            step_info=info()
        )

        test.step(
            step_title=name,
            custom='2C 01 F2 F2 F0 AB 01 01',
            expected={
                'response': 'Positive'
            }
        )

        test.preconditions(
            step_info=info()
        )

        test.step(
            step_title=name,
            custom='2C 01 F2 F1 F0 B3 01 01',
            expected={
                'response': 'Positive'
            }
        )

        test.preconditions(
            step_info=info()
        )

        test.step(
            step_title=name,
            custom='2C 01 F2 F0 F0 B4 01 01',
            expected={
                'response': 'Positive'
            }
        )
    
    # Test failure is expected, it is just to check verification functionality
    def test_004(self, name='Start DDDIDs Mode 01'):
        test.preconditions(
            step_info=info()
        )
        test.step(
            step_title=name,
            read_periodic_data_id=dict(
                DDDID='FF FA', rate='01', timeout=3),

            expected={
                'response': 'Positive',
                'periodic_verifications' : ({'dddid':'FF','active':True}, {'dddid':'FA','active':False}),
                'periodics_num' : 2,
            }
        )
     
    # Test failure is expected, because input data format is incorrect     
    def test_005(self, name='Invalid Data Input - List instead Tuple'):
        test.preconditions(
            step_info=info()
        )
        test.step(
            step_title=name,
            read_periodic_data_id=dict(
                DDDID='FF FA', rate='01', timeout=3),

            expected={
                'response': 'Positive',
                'periodic_verifications' : [{'dddid':'FF','active':True}, {'dddid':'FA','active':False}],
                'periodics_num' : 2,
            }
        )

    # Simple Active/Inactive detection for 2 DDDIDs
    def test_006(self, name='Start DDDIDs Mode 02'):
        test.preconditions(
            step_info=info()
        )
        test.step(
            step_title=name,
            read_periodic_data_id=dict(
                DDDID='F0 F1', rate='02', timeout=5),

            expected={
                'response': 'Positive',
                'periodic_verifications' : ({'dddid':'F0','active':True}, {'dddid':'F1','active':True}),
                'periodics_num' : 4,
            }
        )
    
    # Test failure is expected, invalid datatype for "rate" parameter   
    def test_007(self, name='Invalid Data Input - Wrong Datatypes'):
        test.preconditions(
            step_info=info()
        )
        test.step(
            step_title=name,
            read_periodic_data_id=dict(
                DDDID='F0 F1', rate='02', timeout=5),

            expected={
                'response': 'Positive',
                'periodic_verifications' : ({'dddid':'f0','active':3}, {'dddid':'FF','rate':1,'tolerance':123}, {'dddid':'F1','active':False}, {'dddid':'F2','rate':'02','tolerance':4}),
                'periodics_num' : '12',
            }
        )
        
    def test_008(self, name='Start DDDIDs Mode 03'):
        test.preconditions(
            step_info=info()
        )
        test.step(
            step_title=name,
            read_periodic_data_id=dict(
                DDDID='FC FD', rate='03', timeout=2),

            expected={
                'response': 'Positive',
                'periodic_verifications' : ({'dddid':'FC','active':True}, {'dddid':'FD','active':True}),
                'periodics_num' : 6,
            }
        )
     
    # Test failure is expected, incorrect number of parameters passed for "periodic_verifications" item     
    def test_009(self, name='Invalid Data Input - Parameters Number Mismatch'):
        test.preconditions(
            step_info=info()
        )
        test.step(
            step_title=name,
            read_periodic_data_id=dict(
                DDDID='FC FD', rate='03', timeout=2),

            expected={
                'response': 'Positive',
                'periodic_verifications' : ({'dddid':'FC','active':True,'rate':'02'}, {'dddid':'FF','rate':'01','tolerance':10.0,'retry':True}),
                'periodics_num' : 6,
            }
        )

    # Test with more than 1 tolerance for the same DDDID, failure is OK based on the tolerances
    # The idea is to expose that you can narrow or strech the tolerance to see latency boundaries
    def test_010(self, name='Verify Timing Mode 01 with different tolerances'):
        test.preconditions(
            step_info=info(),
        )
        test.step(
            step_title=name,
            stop_periodic_data='FF FA',

            expected={
                'response': 'Positive',
                'periodics_num' : 4,
                'periodic_verifications' : ({'dddid':'FF','rate':'01','tolerance':10.0},{'dddid':'FF','rate':'01','tolerance':7.0})
            }
        )
      
    # Example of Timing Pattern verification for Single DDDID, failure is expected because of "periodics_num"
    # The idea of the double verification (Pattern + Number of Active DDDIDs) for max coverage
    # If when you activate a DDDID another is activated too you can detect it with this approach
    def test_011(self, name='Verify Timing Mode 02 Only 1'):
        test.preconditions(
            step_info=info(),
        )
        test.step(
            step_title=name,
            stop_periodic_data='F1',

            expected={
                'response': 'Positive',
                'periodics_num' : 2,
                'periodic_verifications' : ({'dddid':'F1','rate':'02','tolerance':10.0})
            }
        )
     
    # Example of Timing Pattern verification for more than 1 DDDID     
    def test_012(self, name='Verify Timing Mode 03 Both'):
        test.preconditions(
            step_info=info(),
        )
        test.step(
            step_title=name,
            stop_periodic_data='FC FD',

            expected={
                'response': 'Positive',
                'periodics_num' : 1,
                'periodic_verifications' : ({'dddid':'FC','rate':'03','tolerance':10.0},{'dddid':'FD','rate':'03','tolerance':10.0})
            }
        )
        
    def test_013(self, name='Start DDDIDs Mode 03 - REPLAY'):
        test.preconditions(
            step_info=info()
        )
        test.step(
            step_title=name,
            read_periodic_data_id=dict(
                DDDID='FC FD', rate='03', timeout=7),

            expected={
                'response': 'Positive',
                'periodic_verifications' : ({'dddid':'FC','active':True}, {'dddid':'FD','active':True}),
                'periodics_num' : 3,
            }
        )

    def test_014(self, name='Verify Timing Mode 03 REPLAY Both'):
        test.preconditions(
            step_info=info(),
        )
        test.step(
            step_title=name,
            stop_periodic_data='FC FD',

            expected={
                'response': 'Positive',
                'periodics_num' : 2,
                'periodic_verifications' : ({'dddid':'FC','rate':'03','tolerance':10.0},{'dddid':'FD','rate':'03','tolerance':10.0})
            }
        )

    # Check for 0 active DDDIDs being transmitted using "periodics_num"
    def test_015(self, name='Stop transmission of All Streams'):
        test.preconditions(
            step_info=info()
        )
        test.step(
            step_title=name,
            stop_periodic_data='',

            expected={
                'response': 'Positive',
                'periodics_num' : 0,
            }
        )

    def test_016(self, name='Invalid Data Type - Error for dddid'):
        test.preconditions(
            step_info=info()
        )
        test.step(
            step_title=name,
            read_periodic_data_id=dict(
                DDDID='FC', rate='03', timeout=2),

            expected={
                'response': 'Positive',
                'periodic_verifications' : ({'dddid':'FC','active':False}),
                'periodics_num' : 1,
            }
        )        
      